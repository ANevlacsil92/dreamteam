<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"global.js.html":{"id":"global.js.html","title":"Source: global.js","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Source: global.js 'use strict'; //////////////////////////////////////////////////////////////////////////////// // require //////////////////////////////////////////////////////////////////////////////// const Singleton = require('./singleton.js'); //////////////////////////////////////////////////////////////////////////////// // Global //////////////////////////////////////////////////////////////////////////////// class Global extends Singleton { /** * 唯一のGlobalインスタンス * @constructor * @example const globalObject = require('./global').GlobalObject; globalObject.sampleValue = 1; */ constructor(){ super(...arguments, 'GlobalObjects', Global); } } //////////////////////////////////////////////////////////////////////////////// // EXPORTS //////////////////////////////////////////////////////////////////////////////// module.exports = new Global(); //////////////////////////////////////////////////////////////////////////////// // EOF //////////////////////////////////////////////////////////////////////////////// × Search results Close "},"mutex.js.html":{"id":"mutex.js.html","title":"Source: mutex.js","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Source: mutex.js 'use strict'; // const debug = require('debug')('mutex:core'); const debug_error = require('debug')('mutex:error'); const redis = require('redis'); const global = require('./global.js'); /** * @private * @typedef {Object} MutexStore~MutexStoreKind * @prop {Number} MEMORY - use memory * @prop {Number} REDIS - use redis */ const MutexStoreKind = { MEMORY : 0, REDIS : 1, }; class MutexStore { // /** * @constructor * @private * @param {MutexStore~MutexStoreKind} kind - MutexStore種別 * @param {Object} [option = {host: '127.0.0.1', port: 6379}] - Redis接続オプション * @param {String} [prefix = globalmutex] - キー文字列prefix * @param {Number} [expire = 60] - Redisキーexpire */ constructor(kind, redisOption, prefix, expire){ // redisOption = redisOption || {host: '127.0.0.1', port: 6379}; // this.prefix = prefix || 'globalmutex:'; this.expire = expire || 60; debug('MutexStore prefox ' + this.prefix); // if(kind === MutexStoreKind.MEMORY){ debug('MutexStore Start MEMORY'); this.kind = MutexStoreKind.MEMORY; //memstore this.memstore = {}; }else if(kind === MutexStoreKind.REDIS){ debug('MutexStore Start Redis'); this.kind = MutexStoreKind.REDIS; //redis this.redisClient = redis.createClient(redisOption); this.redisClient.on('connect', () =&gt; { debug('MutexStore Connect Redis', redisOption); }); this.redisClient.on('error', (err) =&gt; { debug('MutexStore Redis Error ', err); }); // } // global.mutexStore_ = this; // } /** * キーの設定 &amp; Mutex状態の取得 * @param {String} key_ - Mutexキー文字列 * @param {MutexStore~mutexSetCallback} callback - キー設定完了コールバック */ set(key_, callback){ let key = this.prefix + key_; switch(this.kind){ case MutexStoreKind.MEMORY: if(this.memstore[key]){ if(callback)callback(null, 0); }else{ this.memstore[key] = 1; if(callback)callback(null, 1); } return; case MutexStoreKind.REDIS: this.redisClient.setnx(key, 1, (err, result)=&gt; { if(err){ debug_error('MutexStore Redis SETNX Error ', err); } if(result == 0){ if(callback)callback(null, 0); }else{ this.redisClient.expire(key, this.expire, (err/*, expireresult*/)=&gt; { if(err){ debug_error('MutexStore Redis EXPIRE Error ', err); } if(callback)callback(null, 1); }); } }); return; } if(callback)callback(true); } /** * @callback MutexStore~mutexSetCallback * @param {Object} err - エラーオブジェクト * @param {Number} result - キーがセットできた場合（新規Mutexが作成できた場合) = 1, そうで内場合は = 0 */ /** * Mutex解放 * @param {String} key_ - Mutexキー文字列 * @param {MutexStore~mutexReleaseCallback} callback - キーリリース完了コールバック */ release(key_, callback){ let key = this.prefix + key_; switch(this.kind){ case MutexStoreKind.MEMORY: delete this.memstore[key]; if(callback)callback(null); return; case MutexStoreKind.REDIS: this.redisClient.del(key, (err)=&gt; { if(err){ debug_error('MutexStore Redis DEL Error ', err); } if(callback)callback(null); }); return; } if(callback)callback(true); } /** * @callback MutexStore~mutexReleaseCallback * @param {Object} err - エラーオブジェクト */ } /** * Mutexストアを初期化し、Mutexの利用を開始する * @param {MutexOption} option - オプション */ function InitMutex(option){ // option = option || {}; // if(option.redis){ new MutexStore(MutexStoreKind.REDIS, option.redis, option.prefix, option.expire); }else{ new MutexStore(MutexStoreKind.MEMORY, null, option.prefix, null); } // } /** * @typedef MutexOption * @prop {Object} [redis] - redis接続オプション(https://github.com/NodeRedis/node_redis) * @prop {String} [prefix = globalmutex] - Mutexキー文字列prefix * @prop {Number} [expire = 60] - expire - キーexpire for redis */ /** * Mutexの強制リリース * @param {(String|String[])} mutexID - 解放するMutexキー(s) */ function ResetMutex(mutexID){ // if(!global.mutexStore_){ debug_error('First need call InitMutex()'); return; } // if(typeof mutexID === 'string'){ mutexID = [mutexID]; } // for(let i in mutexID){ global.mutexStore_.release(mutexID[i], ()=&gt;{}); } // } // class Mutex { /** * @constructor * @param {String} key - Mutexキー文字列 * @example const {InitMutex, Mutex} = require('./global'); //MEMORY STORE (同一プロセス内mutex ~~criticalsection) InitMutex({}); //USE REDIS (mutex for multi process, multi servers) //InitMutex({prefix: 'mutex:', expire: 60, redis: {host: '127.0.0.1', port: 6379}}); let mutex = new Mutex('LOCK_A'); // create mutex mutex.sync(function(){ // lock mutex console.log('START FUNC1'); setTimeout(() =&gt; { console.log('END FUNC1'); mutex.unlock(); // unlock mutex }, 2000); }); */ constructor(key){ if(!global.mutexStore_){ debug_error('First need call InitMutex()'); } this.key = key; } /** * Mutexロック開始 * @param {function} func Mutex内で実行する関数 */ sync(func){ if(!global.mutexStore_){ return func(); } global.mutexStore_.set(this.key, (err, value)=&gt;{ if(err){ return; } if(value !== 0){ func(); }else{ setImmediate(() =&gt; { this.sync(func); }); } }); } /** * Mutexロック解除 */ unlock(){ if(!global.mutexStore_){ return; } global.mutexStore_.release(this.key, ()=&gt;{}); } } //////////////////////////////////////////////////////////////////////////////// // EXPORTS //////////////////////////////////////////////////////////////////////////////// module.exports = { Mutex: Mutex, ResetMutex: ResetMutex, InitMutex: InitMutex, }; //////////////////////////////////////////////////////////////////////////////// // EOF //////////////////////////////////////////////////////////////////////////////// × Search results Close "},"singleton.js.html":{"id":"singleton.js.html","title":"Source: singleton.js","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Source: singleton.js /** * @file Singleton class * @author Tomonori Itou &lt;tomi@codeworks.co.jp&gt; * @copyright CODEWORKS Corp. * @version 1.0.0 */ 'use strict'; /** * force new singleton flag * @typedef {Symbol} Singleton~SINGLETON_FORCE_NEW * @private * @const */ const SINGLETON_FORCE_NEW = Symbol('SINGLETON_FORCE_NEW'); class Singleton { /** * 引数から、識別キー、生成クラス名、新規生成を所得する * @private * @param {*} argv 引数リスト * @return {Json} {key:識別キー, tgtClass:生成クラス名, forceNew:新規生成} */ static parseParams_(...argv) { // let argMax = argv.length; let tgtClass = argv[argMax - 1]; let key = argv[argMax - 2]; let forceNewFlag = argv[argMax - 3]; // let forceNew = false; if (forceNewFlag === SINGLETON_FORCE_NEW) { forceNew = true; } // return { key: key, tgtClass: tgtClass, forceNew: forceNew, }; // } /** * キャッシュインスタンス返却/インスタンスの生成 * @private * @param {*} argv 引数リスト * @return {Object} Singletonインスタンス */ static getInstance_(...argv) { // const params = Singleton.parseParams_(...argv); // this.cache = this.cache || {}; this.cache[params.tgtClass.name] = this.cache[params.tgtClass.name] || {}; // let resultInstance = null; if (this.cache[params.tgtClass.name][params.key]) { resultInstance = this.cache[params.tgtClass.name][params.key]; resultInstance.newInstance_ = false; } else { resultInstance = new (params.tgtClass)(...argv, SINGLETON_FORCE_NEW); this.cache[params.tgtClass.name][params.key] = resultInstance; resultInstance.newInstance_ = true; } // return resultInstance; // } /** * 新規生成されたインスタンスかどうか * @readonly * @return {boolean} 新規生成されたインスタンスの場合はtrue、それ以外はfalse */ get isNewInstance() { return this.newInstance_; } /** * コンストラクタ * @param {*} argv 引数リスト * @example class TestClass extends Singleton{ constructor(param1, param2, key){ super(...arguments, key, TestClass); if(this.isNewInstance){ // nre instance } } } */ constructor(...argv) { const params = Singleton.parseParams_(...argv); if (params.forceNew !== true) { return Singleton.getInstance_(...argv); } } // } //////////////////////////////////////////////////////////////////////////////// // exports //////////////////////////////////////////////////////////////////////////////// module.exports = Singleton; //////////////////////////////////////////////////////////////////////////////// // EOF //////////////////////////////////////////////////////////////////////////////// × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Global Methods InitMutex(option) Mutexストアを初期化し、Mutexの利用を開始する Parameters: Name Type Description option MutexOption オプション Source: mutex.js, line 138 ResetMutex(mutexID) Mutexの強制リリース Parameters: Name Type Description mutexID String | Array.&lt;String&gt; 解放するMutexキー(s) Source: mutex.js, line 160 Type Definitions MutexOption Properties: Name Type Argument Default Description redis Object &lt;optional&gt; redis接続オプション(https://github.com/NodeRedis/node_redis) prefix String &lt;optional&gt; globalmutex Mutexキー文字列prefix expire Number &lt;optional&gt; 60 expire - キーexpire for redis Source: mutex.js, line 149 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Classes Classes Global Mutex MutexStore Singleton × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex global-mutexGlobal object and Mutex object implements. Global// file1.js const global = require('global-mutex').GlobalObject; // global.param = 'a';// file2.js const global = require('global-mutex').GlobalObject; if(global.param === 'a'){ // true }Mutex // const {InitMutex, Mutex} = require('global-mutex'); // InitMutex({logger: logger}); //MEMORY STORE (only in process), logger &gt; log4js //InitMutex({logger: logger, prefix: 'mutex:', expire: 60, redis: {host: '127.0.0.1', port: 6379}}); //if USE REDIS (mutex for multi process, multi servers) // function delayDo(msg, msec){ return new Promise(function(resolve){ console.log(&quot;delayDo START !&quot;, msg); setTimeout(function(){ console.log(&quot;delayDo END !&quot;, msg); resolve(true); }, msec); }); } let mutex = new Mutex('LOCK_A'); mutex.sync(function(){ console.log('START FUNC1'); setTimeout(() =&gt; { console.log('END FUNC1'); mutex.unlock(); }, 2000); }); let mutex = new Mutex('LOCK_A'); mutex.sync(async function(){ console.log('START FUNC2'); await delayDo('B', 500); console.log('END FUNC2'); mutex.unlock(); }); Singleton// const {Singleton} = require('global-mutex'); // class SampleClass extends Singleton{ constructor(param1, param2, key){ // // param1, param2 is not dependent to create Singleton // super(...arguments, key, SampleClass); if(this.isNewInstance){ // // new instance (first time only) // } } } // End of SampleClass // let a = new SampleClass('P1', 'P2', 'KEY1'); let b = new SampleClass('P3', 'P4', 'KEY2'); let c = new SampleClass('P5', 'P6', 'KEY1'); if(a === c){ // 'KEY1' === 'KEY1' // true } if(a === b){ // 'KEY1' !== 'KEY2' // false } if(b !== c){ // 'KEY2' !== 'KEY1' // false } Index singleton.js Singleton class Version: 1.0.0 Author: Tomonori Itou Copyright: CODEWORKS Corp. Source: singleton.js, line 1 × Search results Close "},"Global_.html":{"id":"Global_.html","title":"Class: Global","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Class: Global Global new Global() 唯一のGlobalインスタンス Source: global.js, line 22 Example const globalObject = require('./global').GlobalObject; globalObject.sampleValue = 1; × Search results Close "},"Mutex.html":{"id":"Mutex.html","title":"Class: Mutex","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Class: Mutex Mutex new Mutex(key) Parameters: Name Type Description key String Mutexキー文字列 Source: mutex.js, line 203 Example const {InitMutex, Mutex} = require('./global'); //MEMORY STORE (同一プロセス内mutex ~~criticalsection) InitMutex({}); //USE REDIS (mutex for multi process, multi servers) //InitMutex({prefix: 'mutex:', expire: 60, redis: {host: '127.0.0.1', port: 6379}}); let mutex = new Mutex('LOCK_A'); // create mutex mutex.sync(function(){ // lock mutex console.log('START FUNC1'); setTimeout(() =&gt; { console.log('END FUNC1'); mutex.unlock(); // unlock mutex }, 2000); }); Methods sync(func) Mutexロック開始 Parameters: Name Type Description func function Mutex内で実行する関数 Source: mutex.js, line 214 unlock() Mutexロック解除 Source: mutex.js, line 235 × Search results Close "},"MutexStore.html":{"id":"MutexStore.html","title":"Class: MutexStore","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Class: MutexStore MutexStore &lt;private&gt; new MutexStore(kind [, option] [, prefix] [, expire]) Parameters: Name Type Argument Default Description kind MutexStore~MutexStoreKind MutexStore種別 option Object &lt;optional&gt; {host: '127.0.0.1', port: 6379} Redis接続オプション prefix String &lt;optional&gt; globalmutex キー文字列prefix expire Number &lt;optional&gt; 60 Redisキーexpire Source: mutex.js, line 30 Methods release(key_, callback) Mutex解放 Parameters: Name Type Description key_ String Mutexキー文字列 callback MutexStore~mutexReleaseCallback キーリリース完了コールバック Source: mutex.js, line 108 set(key_, callback) キーの設定 &amp; Mutex状態の取得 Parameters: Name Type Description key_ String Mutexキー文字列 callback MutexStore~mutexSetCallback キー設定完了コールバック Source: mutex.js, line 65 Type Definitions mutexSetCallback(err, result) Parameters: Name Type Description err Object エラーオブジェクト result Number キーがセットできた場合（新規Mutexが作成できた場合) = 1, そうで内場合は = 0 Source: mutex.js, line 96 MutexStoreKind Type: Object Properties: Name Type Description MEMORY Number use memory REDIS Number use redis Source: mutex.js, line 9 × Search results Close "},"Singleton.html":{"id":"Singleton.html","title":"Class: Singleton","body":" DocStrap Classes GlobalMutexMutexStoreSingleton Global InitMutexResetMutex Class: Singleton Singleton new Singleton(argv) コンストラクタ Parameters: Name Type Argument Description argv * &lt;repeatable&gt; 引数リスト Source: singleton.js, line 96 Example class TestClass extends Singleton{ constructor(param1, param2, key){ super(...arguments, key, TestClass); if(this.isNewInstance){ // nre instance } } } Members &lt;readonly&gt; isNewInstance 新規生成されたインスタンスかどうか Source: singleton.js, line 79 &lt;private, inner, constant&gt; SINGLETON_FORCE_NEW :Symbol force new singleton flag Type: Symbol Source: singleton.js, line 10 Methods &lt;private, static&gt; getInstance_(argv) キャッシュインスタンス返却/インスタンスの生成 Parameters: Name Type Argument Description argv * &lt;repeatable&gt; 引数リスト Source: singleton.js, line 53 Returns: Singletonインスタンス Type Object &lt;private, static&gt; parseParams_(argv) 引数から、識別キー、生成クラス名、新規生成を所得する Parameters: Name Type Argument Description argv * &lt;repeatable&gt; 引数リスト Source: singleton.js, line 27 Returns: {key:識別キー, tgtClass:生成クラス名, forceNew:新規生成} Type Json × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
