"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DataType_toString = exports.UADataTypeImpl = void 0;
/**
 * @module node-opcua-address-space
 */
const chalk = require("chalk");
const node_opcua_assert_1 = require("node-opcua-assert");
const node_opcua_data_model_1 = require("node-opcua-data-model");
const node_opcua_data_model_2 = require("node-opcua-data-model");
const node_opcua_data_value_1 = require("node-opcua-data-value");
const node_opcua_nodeid_1 = require("node-opcua-nodeid");
const node_opcua_numeric_range_1 = require("node-opcua-numeric-range");
const node_opcua_status_code_1 = require("node-opcua-status-code");
const node_opcua_types_1 = require("node-opcua-types");
const node_opcua_variant_1 = require("node-opcua-variant");
const session_context_1 = require("../source/session_context");
const base_node_impl_1 = require("./base_node_impl");
const base_node_private_1 = require("./base_node_private");
const tools = require("./tool_isSupertypeOf");
const tool_isSupertypeOf_1 = require("./tool_isSupertypeOf");
const tool_isSupertypeOf_2 = require("./tool_isSupertypeOf");
const base_node_private_2 = require("./base_node_private");
function findBasicDataType(dataType) {
    if (dataType.nodeId.namespace === 0 && dataType.nodeId.value <= 25) {
        // we have a well-known DataType
        return dataType.nodeId.value;
    }
    return findBasicDataType(dataType.subtypeOfObj);
}
class UADataTypeImpl extends base_node_impl_1.BaseNodeImpl {
    constructor(options) {
        super(options);
        this.nodeClass = node_opcua_data_model_1.NodeClass.DataType;
        this.definitionName = "";
        this.isSupertypeOf = tools.construct_isSupertypeOf(UADataTypeImpl);
        this.$definition = options.$definition;
        this.isAbstract = options.isAbstract === null ? false : options.isAbstract;
        this.symbolicName = options.symbolicName || this.browseName.name;
    }
    /**
     * returns true if this is a super type of baseType
     *
     * @example
     *
     *    var dataTypeDouble = addressSpace.findDataType("Double");
     *    var dataTypeNumber = addressSpace.findDataType("Number");
     *    assert(dataTypeDouble.isSupertypeOf(dataTypeNumber));
     *    assert(!dataTypeNumber.isSupertypeOf(dataTypeDouble));
     *
     */
    get subtypeOf() {
        return tool_isSupertypeOf_1.get_subtypeOf.call(this);
    }
    get subtypeOfObj() {
        return tool_isSupertypeOf_2.get_subtypeOfObj.call(this);
    }
    get basicDataType() {
        return findBasicDataType(this);
    }
    readAttribute(context, attributeId, indexRange, dataEncoding) {
        (0, node_opcua_assert_1.assert)(!context || context instanceof session_context_1.SessionContext);
        const options = {};
        switch (attributeId) {
            case node_opcua_data_model_2.AttributeIds.IsAbstract:
                options.statusCode = node_opcua_status_code_1.StatusCodes.Good;
                options.value = { dataType: node_opcua_variant_1.DataType.Boolean, value: !!this.isAbstract };
                break;
            case node_opcua_data_model_2.AttributeIds.DataTypeDefinition:
                {
                    const _definition = this._getDefinition(true);
                    if (_definition !== null) {
                        options.value = { dataType: node_opcua_variant_1.DataType.ExtensionObject, value: _definition };
                    }
                    else {
                        options.statusCode = node_opcua_status_code_1.StatusCodes.BadAttributeIdInvalid;
                    }
                }
                break;
            default:
                return super.readAttribute(context, attributeId, indexRange, dataEncoding);
        }
        return new node_opcua_data_value_1.DataValue(options);
    }
    getEncodingDefinition(encoding_name) {
        const encodingNode = this.getEncodingNode(encoding_name);
        if (!encodingNode) {
            throw new Error("Cannot find Encoding for " + encoding_name);
        }
        const indexRange = new node_opcua_numeric_range_1.NumericRange();
        const descriptionNodeRef = encodingNode.findReferences("HasDescription")[0];
        const descriptionNode = this.addressSpace.findNode(descriptionNodeRef.nodeId);
        if (!descriptionNode) {
            return null;
        }
        const dataValue = descriptionNode.readValue(session_context_1.SessionContext.defaultContext, indexRange);
        return dataValue.value.value.toString() || null;
    }
    getEncodingNode(encoding_name) {
        const _cache = (0, base_node_private_2.BaseNode_getCache)(this);
        const key = encoding_name + "Node";
        if (_cache[key] === undefined) {
            (0, node_opcua_assert_1.assert)(encoding_name === "Default Binary" || encoding_name === "Default XML" || encoding_name === "Default JSON");
            // could be binary or xml
            const refs = this.findReferences("HasEncoding", true);
            const addressSpace = this.addressSpace;
            const encoding = refs
                .map((ref) => addressSpace.findNode(ref.nodeId))
                .filter((obj) => obj !== null)
                .filter((obj) => obj.browseName.toString() === encoding_name);
            const node = encoding.length === 0 ? null : encoding[0];
            _cache[key] = node;
        }
        return _cache[key];
    }
    getEncodingNodeId(encoding_name) {
        const _cache = (0, base_node_private_2.BaseNode_getCache)(this);
        const key = encoding_name + "NodeId";
        if (_cache[key] === undefined) {
            const encoding = this.getEncodingNode(encoding_name);
            if (encoding) {
                const namespaceUri = this.addressSpace.getNamespaceUri(encoding.nodeId.namespace);
                _cache[key] = node_opcua_nodeid_1.ExpandedNodeId.fromNodeId(encoding.nodeId, namespaceUri);
            }
            else {
                _cache[key] = null;
            }
        }
        return _cache[key];
    }
    /**
     * returns the encoding of this node's
     * TODO objects have 2 encodings : XML and Binaries
     */
    get binaryEncoding() {
        return this.getEncodingNode("Default Binary");
    }
    get binaryEncodingDefinition() {
        return this.getEncodingDefinition("Default Binary");
    }
    get binaryEncodingNodeId() {
        return this.getEncodingNodeId("Default Binary");
    }
    get xmlEncoding() {
        return this.getEncodingNode("Default XML");
    }
    get xmlEncodingNodeId() {
        return this.getEncodingNodeId("Default XML");
    }
    get xmlEncodingDefinition() {
        return this.getEncodingDefinition("Default XML");
    }
    get jsonEncoding() {
        return this.getEncodingNode("Default JSON");
    }
    get jsonEncodingNodeId() {
        return this.getEncodingNodeId("Default JSON");
    }
    //  public get jsonEncodingDefinition(): string | null {
    //      return this.getEncodingDefinition("Default JSON");
    //  }
    _getEnumerationInfo() {
        let definition = [];
        if (this.enumStrings) {
            const enumStrings = this.enumStrings.readValue().value.value;
            (0, node_opcua_assert_1.assert)(Array.isArray(enumStrings));
            definition = enumStrings.map((e, index) => {
                return {
                    name: e.text,
                    value: index
                };
            });
        }
        else if (this.enumValues) {
            (0, node_opcua_assert_1.assert)(this.enumValues, "must have a enumValues property");
            const enumValues = this.enumValues.readValue().value.value;
            (0, node_opcua_assert_1.assert)(Array.isArray(enumValues));
            definition = enumValues.map((e) => {
                return {
                    name: e.displayName.text,
                    value: e.value[1]
                };
            });
        }
        // construct nameIndex and valueIndex
        const indexes = {
            nameIndex: {},
            valueIndex: {}
        };
        for (const e of definition) {
            indexes.nameIndex[e.name] = e;
            indexes.valueIndex[e.value] = e;
        }
        return indexes;
    }
    _getDefinition(mergeWithBase) {
        var _a, _b;
        if (this.$fullDefinition !== undefined) {
            return mergeWithBase ? this.$fullDefinition : this.$definition;
        }
        if (!this.$definition) {
            const structure = this.addressSpace.findDataType("Structure");
            if (!structure) {
                return null;
            }
            if (this.isSupertypeOf(structure)) {
                // <Definition> tag was missing in XML file as it was empty
                this.$definition = new node_opcua_types_1.StructureDefinition({});
            }
        }
        // https://reference.opcfoundation.org/v104/Core/docs/Part3/8.49/#Table34
        // The list of fields that make up the data type.
        // This definition assumes the structure has a sequential layout.
        // The StructureField DataType is defined in 8.51.
        // For Structures derived from another Structure DataType this list shall begin with the fields
        // of the baseDataType followed by the fields of this StructureDefinition.
        // from OPC Unified Architecture, Part 6 86 Release 1.04
        //  A DataTypeDefinition defines an abstract representation of _a UADataType that can be used by
        //  design tools to automatically create serialization code. The fields in the DataTypeDefinition type
        //  are defined in Table F.12.
        const _definition = this.$definition || null;
        if (_definition && _definition instanceof node_opcua_types_1.StructureDefinition && this.binaryEncodingNodeId) {
            _definition.defaultEncodingId = this.binaryEncodingNodeId;
            const subtype = this.subtypeOf;
            if (subtype) {
                _definition.baseDataType = subtype;
            }
        }
        this.$fullDefinition = (_a = this.$definition) === null || _a === void 0 ? void 0 : _a.clone();
        let _baseDefinition = null;
        if (this.subtypeOfObj) {
            _baseDefinition = this.subtypeOfObj._getDefinition(mergeWithBase);
        }
        if (this.$fullDefinition && this.$definition instanceof node_opcua_types_1.StructureDefinition && _baseDefinition) {
            const b = _baseDefinition;
            if ((_b = b.fields) === null || _b === void 0 ? void 0 : _b.length) {
                const f = this.$fullDefinition;
                f.fields = [].concat(b.fields, f.fields);
            }
        }
        return mergeWithBase ? this.$fullDefinition || null : this.$definition || null;
    }
    getDefinition() {
        const d = this._getDefinition(true);
        if (!d) {
            throw new Error("DataType has no definition property");
        }
        return d;
    }
    install_extra_properties() {
        //
    }
    toString() {
        const options = new base_node_private_1.ToStringBuilder();
        DataType_toString.call(this, options);
        return options.toString();
    }
}
exports.UADataTypeImpl = UADataTypeImpl;
function dataTypeDefinition_toString(options) {
    const definition = this._getDefinition(false);
    if (!definition) {
        return;
    }
    const output = definition.toString();
    options.add(options.padding + chalk.yellow(" Definition                   :             "));
    for (const str of output.split("\n")) {
        options.add(options.padding + chalk.yellow("                              :   " + str));
    }
}
function DataType_toString(options) {
    base_node_private_1.BaseNode_toString.call(this, options);
    options.add(options.padding + chalk.yellow("          isAbstract          : " + this.isAbstract));
    options.add(options.padding + chalk.yellow("          definitionName      : " + this.definitionName));
    options.add(options.padding +
        chalk.yellow("          binaryEncodingNodeId: ") +
        (this.binaryEncodingNodeId ? this.binaryEncodingNodeId.toString() : "<none>"));
    options.add(options.padding +
        chalk.yellow("          xmlEncodingNodeId   : ") +
        (this.xmlEncodingNodeId ? this.xmlEncodingNodeId.toString() : "<none>"));
    if (this.subtypeOfObj) {
        options.add(options.padding +
            chalk.yellow("          subtypeOfObj        : ") +
            (this.subtypeOfObj ? this.subtypeOfObj.browseName.toString() : ""));
    }
    // references
    base_node_private_1.BaseNode_References_toString.call(this, options);
    dataTypeDefinition_toString.call(this, options);
}
exports.DataType_toString = DataType_toString;
//# sourceMappingURL=ua_data_type_impl.js.map