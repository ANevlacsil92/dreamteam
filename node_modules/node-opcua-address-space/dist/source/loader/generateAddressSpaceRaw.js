"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.generateAddressSpaceRaw = exports.generateAddressSpaceRawCallback = void 0;
const async = require("async");
const node_opcua_debug_1 = require("node-opcua-debug");
const adjust_namespace_array_1 = require("../../src/nodeset_tools/adjust_namespace_array");
const load_nodeset2_1 = require("./load_nodeset2");
const doDebug = (0, node_opcua_debug_1.checkDebugFlag)(__filename);
const debugLog = (0, node_opcua_debug_1.make_debugLog)(__filename);
/**
 * @param addressSpace the addressSpace to populate
 * @xmlFiles: a lis of xml files
 * @param xmlLoader - a helper function to return the content of the xml file
 */
function generateAddressSpaceRawCallback(addressSpace, xmlFiles, xmlLoader, callback) {
    // istanbul ignore next
    if (!callback) {
        throw new Error("Internal Error; :callback missing");
    }
    const nodesetLoader = new load_nodeset2_1.NodeSetLoader(addressSpace);
    if (!Array.isArray(xmlFiles)) {
        xmlFiles = [xmlFiles];
    }
    // read xml files in parallel
    async.map(xmlFiles, (xmlFile, callback1) => {
        xmlLoader(xmlFile, callback1);
    }, (err, xmlDataArray) => {
        if (err) {
            callback(err);
            return;
        }
        async.forEachSeries(xmlDataArray, (xmlData, callback1) => {
            if (!xmlData) {
                return callback1(err);
            }
            nodesetLoader.addNodeSet(xmlData, callback1);
        }, (err) => {
            nodesetLoader.terminate(() => {
                (0, adjust_namespace_array_1.adjustNamespaceArray)(addressSpace);
                callback();
            });
        });
    });
    // however process them in series
}
exports.generateAddressSpaceRawCallback = generateAddressSpaceRawCallback;
function generateAddressSpaceRaw(addressSpace, xmlFiles, xmlLoader) {
    const promise = new Promise((resolve, reject) => {
        generateAddressSpaceRawCallback(addressSpace, xmlFiles, xmlLoader, (err) => {
            if (err) {
                return reject(err);
            }
            resolve();
        });
    });
    return promise;
}
exports.generateAddressSpaceRaw = generateAddressSpaceRaw;
//# sourceMappingURL=generateAddressSpaceRaw.js.map